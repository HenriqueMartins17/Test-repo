const fs = require("fs")
const pathMod = require("path")

if (process.argv.length <= 2) {
  console.error("missing DIR")
  process.exit(1)
}

const rootPath = process.argv[2]
if (!fs.existsSync(rootPath)) {
  console.error(rootPath + " does not exist")
  process.exit(1)
}
if (!fs.statSync(rootPath).isDirectory()) {
  console.error(rootPath + " is not a directory")
  process.exit(1)
}
go(rootPath, new Set())

function go(path, keys) {
  const entries = fs.readdirSync(path, { withFileTypes: true })
  for (const entry of entries) {
    const subpath = pathMod.join(path, entry.name)
    if (entry.name === ".lang-keys") {
      keys = new Set(
        fs
          .readFileSync(subpath, "utf-8")
          .split("\n")
          .map((line) => line.trim())
          .filter((line) => !!line),
      )
      generateKeyEnum(subpath, keys)
      break
    }
  }
  for (const entry of entries) {
    const subpath = pathMod.join(path, entry.name)
    if (entry.isDirectory()) {
      go(subpath, keys)
    } else if (entry.isFile()) {
      if (entry.name.endsWith(".lang")) {
        generateLang(subpath, keys)
      }
    }
  }
}

function generateLang(filepath, keys) {
  const jsonFilePath = filepath.slice(0, -".lang".length) + ".lang.json"
  let needUpdate = false
  if (fs.existsSync(jsonFilePath) && isFileNewer(filepath, jsonFilePath)) {
    const oldJson = JSON.parse(fs.readFileSync(jsonFilePath))
    if (oldJson && typeof oldJson === "object" && !Array.isArray(oldJson)) {
      const oldKeys = Object.keys(oldJson)
      if (oldKeys.length !== keys.size) {
        needUpdate = true
      } else {
        for (const oldKey of oldKeys) {
          if (!keys.has(oldKey)) {
            needUpdate = true
            break
          }
        }
      }
    } else {
      needUpdate = true
    }
  } else {
    needUpdate = true
  }

  if (!needUpdate) {
    console.log(`[OK ] ${jsonFilePath} is up to date`)
    return
  }

  const lines = fs
    .readFileSync(filepath, "utf-8")
    .split("\n")
    .map((line) => line.trim())
    .filter((line) => !!line)
  const lang = {}
  for (const line of lines) {
    const segs = line.split("=").map((seg) => seg.trim())
    if (segs.length != 2) {
      console.error(`[ERR] ${filepath} parse error: ${line}`)
      return
    }
    const key = segs[0]
    let value = segs[1]
    if (value.startsWith('"') && value.endsWith('"')) {
      value = JSON.parse(value)
    }
    if (Object.hasOwn(lang, key)) {
      console.error(`[ERR] ${filepath} error: redundant key ${key}`)
      return
    }
    if (!keys.has(key)) {
      console.error(`[ERR] ${filepath} error: unknown key ${key}`)
      return
    }
    lang[key] = value
  }
  if (lines.length != keys.size) {
    for (const k of keys) {
      if (!Object.hasOwn(lang, k)) {
        console.error(`ERR ${filepath} error: missing key ${k}`)
      }
    }
    return
  }

  fs.writeFileSync(jsonFilePath, JSON.stringify(lang, null, 2), "utf-8")
  console.log(`[OK ] Generate ${jsonFilePath}`)
}

function isFileNewer(srcFile, dstFile) {
  return fs.statSync(dstFile).mtime >= fs.statSync(srcFile).mtime
}

function generateKeyEnum(filepath, keys) {
  const enumFilePath = pathMod.join(pathMod.dirname(filepath), "keys.ts")
  if (fs.existsSync(enumFilePath) && isFileNewer(filepath, enumFilePath)) {
    return
  }
  let content =
    "/// Auto generated by generateLang.js. DO NOT EDIT.\n" +
    "export const enum LocalizationKey {\n"
  for (const key of keys) {
    content += "  "
    content += key
    content += " = \""
    content += key
    content += "\",\n"
  }
  content += "}"
  fs.writeFileSync(enumFilePath, content, "utf-8")

  console.log(`[OK ] Generate ${enumFilePath}`)
}
