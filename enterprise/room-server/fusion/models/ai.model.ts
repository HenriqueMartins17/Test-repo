import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { IsOptional, IsString, ValidateNested } from 'class-validator';
import { IChatOptions } from '../helpers/ai.server.model';

export class AiFunctionCall {
    @ApiProperty({
      required: true,
      description: 'The name of the function to call.'
    })
      name!: string;

    @ApiProperty({
      required: true,
      description: 'The arguments to call the function with, as generated by the model in JSON format.'
    })
      arguments!: string;
}

export class AiChatMessage {
    @ApiProperty({
      required: true,
      description: 'The role of the messages author. One of system, user, assistant, or function.'
    })
      role?: string;

    @ApiProperty({
      required: true,
      description: 'The contents of the message. content is required for all messages, and may be null for assistant messages with function calls.'
    })
      content?: string;

    @ApiPropertyOptional({
      description: 'The name of the author of this message. name is required if role is function, ' +
          'and it should be the name of the function whose response is in the content. May contain a-z, A-Z, 0-9, ' +
          'and underscores, with a maximum length of 64 characters.'
    })
      name?: string;

    @ApiPropertyOptional({
      type: AiFunctionCall,
      description: 'The name and arguments of a function that should be called, as generated by the model.'
    })
    @Type(() => AiFunctionCall)
    @IsOptional()
    @ValidateNested()
      function_call!: AiFunctionCall;
}

export class AiChatCompletionParamRo {
    @ApiProperty({
      type: String,
      required: true,
      example: 'ai_i10dj1jf1l2',
      description: 'AI ID',
    })
    @IsString()
      aiId!: string;
}

export class AiFunction {
    @ApiProperty({
      required: true,
      description: 'The name of the function to be called.'
    })
      name!: string;

    @ApiPropertyOptional({
      description: 'A description of what the function does, used by the model to choose when and how to call the function.'
    })
    @IsOptional()
      description!: string;

    @ApiProperty({
      required: true,
      description: 'The parameters the functions accepts, described as a JSON Schema object.'
    })
      parameters!: object;
}

export class AiChatCompletionRo {

    @ApiProperty({
      description: 'ID of the model to use. eg: gpt-4, gpt-4-0613, gpt-4-32k...'
    })
      model?: string;

    @ApiProperty({
      description: 'A list of messages comprising the conversation so far.'
    })
    @Type(() => AiChatMessage)
    @ValidateNested({ each: true })
      messages!: AiChatMessage[];

    @ApiPropertyOptional({
      type: [AiFunction],
      description: 'A list of functions the model may generate JSON inputs for.'
    })
    @Type(() => AiFunction)
    @IsOptional()
    @ValidateNested({ each: true })
      functions?: AiFunction[];

    @ApiPropertyOptional({
      description: 'Controls how the model responds to function calls.'
    })
    @IsOptional()
      function_call?: string;

    @ApiPropertyOptional({
      maximum: 2,
      minimum: 0,
      description: 'What sampling temperature to use, between 0 and 2. ' +
          'Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.'
    })
    @IsOptional()
      temperature?: number = 1;

    @ApiPropertyOptional({
      description: 'An alternative to sampling with temperature, called nucleus sampling, ' +
          'where the model considers the results of the tokens with top_p probability mass. ' +
          'So 0.1 means only the tokens comprising the top 10% probability mass are considered.'
    })
    @IsOptional()
      top_p?: number = 1;

    @ApiPropertyOptional({
      description: 'How many chat completion choices to generate for each input message.'
    })
    @IsOptional()
      n?: number = 1;

    @ApiPropertyOptional({
      description: 'If set, partial message deltas will be sent, like in ChatGPT. ' +
          'Tokens will be sent as data-only server-sent events as they become available, with the stream terminated by a data: [DONE] message.'
    })
    @IsOptional()
      stream?: boolean = false;

    @ApiPropertyOptional({
      description: 'Up to 4 sequences where the API will stop generating further tokens.'
    })
    @IsOptional()
      stop?: string | string[];

    @ApiPropertyOptional({
      description: 'The maximum number of tokens to generate in the chat completion.'
    })
    @IsOptional()
      max_tokens?: number = 256;

    @ApiPropertyOptional({
      maximum: 2,
      minimum: -2,
      description: 'Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, ' +
          'increasing the model\'s likelihood to talk about new topics.'
    })
    @IsOptional()
      presence_penalty?: number = 0;

    @ApiPropertyOptional({
      maximum: 2,
      minimum: -2,
      description: 'Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, ' +
          'decreasing the model\'s likelihood to repeat the same line verbatim.'
    })
    @IsOptional()
      frequency_penalty?: number = 0;

    @ApiPropertyOptional({
      description: 'Modify the likelihood of specified tokens appearing in the completion.'
    })
    @IsOptional()
      logit_bias?: Map<number, number>;

    @ApiPropertyOptional({
      description: 'Modify the likelihood of specified tokens appearing in the completion.'
    })
    @IsOptional()
      user?: string;
}

export class AiChatCompletionChoices {
    @ApiProperty({
      type: Number,
      description: 'The index of the choice in the list of choices.'
    })
      index!: number;

    @ApiProperty({
      type: AiChatMessage,
      description: 'The index of the choice in the list of choices.'
    })
      message!: AiChatMessage;

    @ApiProperty({
      type: String,
      description: 'The reason the model stopped generating tokens.'
    })
      finish_reason!: string;
}

export class AiChatCompletionChunkChoices {
    @ApiProperty({
      type: Number,
      description: 'The index of the choice in the list of choices.'
    })
      index!: number;

    @ApiProperty({
      type: AiChatMessage,
      description: 'A chat completion delta generated by streamed model responses.'
    })
      delta!: AiChatMessage;

    @ApiProperty({
      type: String,
      description: 'The reason the model stopped generating tokens.'
    })
      finish_reason!: string;

}

export class AiChatCompletionVo {
    @ApiProperty({
      type: String,
      description: 'A unique identifier for the chat completion or chunk.'
    })
      id!: string;

    @ApiProperty({
      type: String,
      description: 'The object type, which is always chat.completion or chat.completion.chunk.'
    })
      object!: string;

    @ApiProperty({
      type: Number,
      description: 'A unix timestamp of when the chat completion chunk was created.'
    })
      created!: number;

    @ApiProperty({
      type: String,
      description: 'The model to generate the completion.'
    })
      model!: string;

    @ApiProperty({
      description: 'A list of chat completion choices. Can be more than one if n is greater than 1.'
    })
    @ValidateNested()
      choices!: AiChatCompletionChoices[] | AiChatCompletionChunkChoices[];
}

export class INestChatOptions implements IChatOptions {
  aiId: string;
  content: string = '';
  conversationId: string;
  chatRo: AiChatCompletionRo;

  constructor(aiId: string,
    conversationId: string,
    chatRo: AiChatCompletionRo) {
    this.aiId = aiId;
    this.conversationId = conversationId;
    this.chatRo = chatRo;
  }

  // @ts-ignore
  onAbort(controller: AbortController): void {
  }

  // @ts-ignore
  onError(err: Error): void {
  }

  // @ts-ignore
  onFinish(message: string): void {
  }

  // @ts-ignore
  onUpdate(message: string): void {
  }
}